"""
Given a word, write a function to generate all of its unique generalized abbreviations.
A generalized abbreviation of a word can be generated by replacing each substring of the
word with the count of characters in the substring.

example1:
    Input: "BAT"
    Output: "BAT", "BA1", "B1T", "B2", "1AT", "1A1", "2T", "3"

example2:
    Input: "code"
    Output: "code", "cod1", "co1e", "co2", "c1de", "c1d1", "c2e", "c3", "1ode", "1od1", "1o1e", "1o2",
    "2de", "2d1", "3e", "4"
"""

from collections import deque


def generate_generalized_abbreviation_partially_correct(word):
    """
    Will fail in case of duplicate characters in word like sys
    """
    permutations = []
    if len(word) == 0:
        return permutations
    permutations.append(word)
    for i in range(len(word)):
        for j in range(len(permutations)):
            old_per = permutations[j][:]
            idx = old_per.find(word[i])
            if idx != -1:
                previous_char = old_per[idx - 1]
                if previous_char >= "1" and previous_char <= "9":
                    old_per = (
                        old_per[: idx - 1]
                        + str(int(previous_char) + 1)
                        + old_per[idx + 1 :]
                    )
                else:
                    old_per = old_per[:idx] + str(1) + old_per[idx + 1 :]

            permutations.append(old_per)

    return permutations


# print("Generalized abbreviation are: " + str(generate_generalized_abbreviation_partially_correct("BAT")))
# print("Generalized abbreviation are: " + str(generate_generalized_abbreviation_partially_correct("code")))
# print("Generalized abbreviation are: " + str(generate_generalized_abbreviation_partially_correct("sys")))
# print("Generalized abbreviation are: " + str(generate_generalized_abbreviation_partially_correct("stp")))
# print("Generalized abbreviation are: " + str(generate_generalized_abbreviation_partially_correct("system")))


def generate_generalized_abbreviation(word):
    """
    We can have a problem in edge cases like.
    lets say word have 21 chars in it.
    B19 is one abbvt and now when adding next char, it should be ideally B20 but acc. to code it will be B110.
    Since we are just looking at the last index if that's numeric or not.
    """
    result = []
    if len(word) == 0:
        return result
    queue = deque()
    queue.append("")
    abbvt = ""
    skip = ""
    for c in range(len(word)):
        size = len(queue)
        while size != 0:
            left = queue.popleft()
            size -= 1
            if c == 0:
                abbvt = str(1)
                skip = word[c]
            else:
                if left[-1] >= "0" and left[-1] <= "9":
                    abbvt = left[:-1] + str(int(left[-1]) + 1)
                    skip = left + word[c]
                else:
                    abbvt = left + str(1)
                    skip = left + word[c]
            queue.append(abbvt)
            queue.append(skip)
            if c == len(word) - 1:
                result.append(abbvt)
                result.append(skip)

    # return list(queue)
    return result


# print("Generalized abbreviation are: " + str(generate_generalized_abbreviation("sys")))
# print("Generalized abbreviation are: " + str(generate_generalized_abbreviation("stp")))
# print("Generalized abbreviation are: " + str(generate_generalized_abbreviation("system")))


class Abbreviation:
    def __init__(self, str_content, start, count):
        self.str_content = str_content
        self.start = start
        self.count = count


def generate_generalized_abbreviation_prefect(word):
    result = []
    if len(word) == 0:
        return result
    queue = deque()
    queue.append(Abbreviation(list(), 0, 0))
    while queue:
        abword = queue.popleft()
        if abword.start == len(word):
            new_word = "".join(abword.str_content)
            if abword.count != 0:
                new_word += str(abword.count)
            result.append(new_word)
        else:
            # abbvt the word and increase the count
            queue.append(
                Abbreviation(
                    list(abword.str_content), abword.start + 1, abword.count + 1
                )
            )

            new_word = list(abword.str_content)
            if abword.count != 0:
                new_word.append(str(abword.count))

            # do not abbreviate and made the word by appending current char
            new_word.append(word[abword.start])
            queue.append(Abbreviation(new_word, abword.start + 1, 0))

    return result


print(
    "Generalized abbreviation are: "
    + str(generate_generalized_abbreviation_prefect("sys"))
)
print(
    "Generalized abbreviation are: "
    + str(generate_generalized_abbreviation_prefect("stp"))
)
print(
    "Generalized abbreviation are: "
    + str(generate_generalized_abbreviation_prefect("system"))
)


def generate_generalized_abbreviation_rec(word):
    result = []
    generate_generalized_abbreviation_recursive(word, [], 0, 0, result)
    return result


def generate_generalized_abbreviation_recursive(word, abword, start, count, result):
    if start == len(word):
        if count != 0:
            abword.append(str(count))
        result.append("".join(abword))
    else:
        generate_generalized_abbreviation_recursive(
            word, list(abword), start + 1, count + 1, result
        )
        new_word = list(abword)
        if count != 0:
            new_word.append(str(count))
        new_word.append(word[start])

        generate_generalized_abbreviation_recursive(
            word, new_word, start + 1, 0, result
        )


print(
    "Generalized abbreviation are: " + str(generate_generalized_abbreviation_rec("sys"))
)
print(
    "Generalized abbreviation are: " + str(generate_generalized_abbreviation_rec("stp"))
)
print(
    "Generalized abbreviation are: "
    + str(generate_generalized_abbreviation_rec("system"))
)
